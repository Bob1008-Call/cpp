1.extern的作用：
  C语言中：extern声明的函数和变量可以被该文件外部模块使用，C++语言除了该作用还可以通过'extern C'声明一段代码按照C语言的方式进行编译和连接的
2.strstr()函数的作用：
  其作用就是寻找目标字符串在源字符串中第一次出现的位置
3.浅谈linux进程和线程：
  进程：是计算机中的程序关于某些数据集合上的一次运行，是系统进程资源分配和调度的基本单位，式操作系统结构的基础，执行之前需要系统分配资源才能进程。而需要执行一些细小任务时，本身无需分配单独资源，比如所有的子进程共享父进程的资源，按照进程执行过程来讲，造成时间核空间浪费，所以就有了进程
  相同点：
  （1）都是实现多任务并发的技术手段
  （2）二者都可以独立调度，在多任务环境下，功能并无差异，
  （3）并且二者都具有各自的实体，是系统独立管理的对象个体。
  不同点：
  （1）进程时资源分配的基本单位，线程调度的基本单位，进程也可以调度，但是进程强调的是分配资源时的对象必须是进程。不会给一个线程单独分配资源，运行一个任务，想要获得资源，就需要有进程，其他子任务可以以线程身份运行，资源共享。
  （2）简单可以理解为这样，进程的个体间是完全独立的，而线程间是彼此依存的，多进程环境中，一个进程终止，不会影响其他进程的执行，但是在多线程环境中，父线程终止，全部子线程被迫中止（没有资源），而一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用，任何一个线程执行了exit(),全部线程都终止。
  （3）实现方式
    进程是通过pid_t fork(void);来创建的
    线程是通过int clone(int (*fn)(void*),.....);来创建的，一般多线程程序中看到的是pthread_create()而不是clone
    备注：vfork(),这是一个系统调用，创建一个进程，不是复制父进程的资源，而是共享，并且vfork()的子进程与父进程的运行时间是由约定的，子进程‘结束’才执行父进程，结束并不是子进程完全退出，而是子进程返回，一般采用vfork()的子进程，都会有一个execv启动一个全新的进程，该进程的进程空间与父进程完全独立，所以不需要复制父进程的资源。
  （4）通信方式
    进程：共享内存、消息队列、信号量、管道、信号、文件、socket
    线程：上面的都有，此外还有互斥量、自旋锁、条件变量、读写锁、线程信号、全局变量
    （i）进程间通信要么需要切换内核上下文，要么需要使用管道、文件，所以速度比较慢，线程采用的自己的通信方式的话，通信再速度上就会变快
  （5）进程与线程的身份标识ID管理方式不一样
    进程的ID为pid_t类型，实际上是int类型的，也就是说是有限的。创建一个进程，内核中就会创建一个结构体来存储该进程的全部信息。每一个存储进程信息的节点都会保存PID，需要管理该进程就通过PID来实现，当子进程结束要回收时，子进程就会调用exit()退出，需要通过wait()系统调用来进行未回收的进程就会称为僵尸进程。实体不存在，但会占PID资源。
    线程的ID是一个long型变量，返回相较于进程大的多，线程ID一般在本进程空间作用就可以，其管理方式是，在内核创建一个内核态线程与之对应，也就是说每一个用户态线程都有内核态线程与之对应，但是这种对应关系不是一对一，而是多对一，多个用户态线程对应一个内核态线程。
  （6）资源管理方式的异同
  进程本身是资源分配的基本单位，所以资源都是独立的，如果有多进程间的共享资源，就要用到进程间的通信方式了，比如共享内存。共享内存和信号量一起使用会保证数据写入的安全。
  线程间共享资源就不需要共享内存，直接使用全局变量就可以。
  （7）个体间备份关系
  对于进程，如果进程A创建了进程B，进程B创建了进程C，那么A、C就是爷孙关系，可以通过pstree来打印进程树。
  而线程没有这么严格，不管是父进程还是子进程创建了进程，都是共享父进程的资源，即只存在一个父线程，其余线程都是父线程的子线程。
  （8）进程池与线程池的实现技术差别
  进程池：首先创建了一批进程，分开保存ID，可以用数组，也可以用链表，建议使用数组，接下来需要它们等待，可以通过pause(),信号量，IPC阻塞等，然后是分配任务，首先可以通过信号唤醒进程，然后让它们去读取任务，可以通过函数指针实现，再就是通过共享内存把要处理的数据设置好，最后回收子进程，向各个进程发送信号唤醒，改变激活状态让其主动结束，逐个wait()
  线程池：要让线程阻塞，用条件变量就可以，需要完成任务时父线程改变条件，子线程就激活。线程间通信就更easy了，比起进程效率更高。线程完成任务后再改变条件，再回首就可以。
  
